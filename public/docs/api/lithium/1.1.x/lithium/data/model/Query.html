<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />	<title>lithium\data\model\Query – Framework API v1.1.x – Documentation – li3 PHP-Framework</title>
		<link rel="stylesheet" href="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/reset.css" />
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro:400,700,400italic,700italic" />
	<link rel="stylesheet" href="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/u1m.css" />
	<link rel="stylesheet" href="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/li3_docs.css" />
	<link rel="stylesheet" href="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/highlight.css" />
	
	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
	<script src="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/js/base.js"></script>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.js"></script>
	
	
	<link rel="icon" href="../../../../../../../assets/ico/site.png">

		<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-11048416-4', 'auto');
	  ga('send', 'pageview');
	</script>
	</head>
<body class="layout-default li3-docs">
		<div id="container">
			<header class="main">
	<div class="left">
		<h1><a href="../../../../../../../index.html" class="li3-logo">li3</a></h1>
	</div>
	<div class="right">
		<nav class="main-nav"><a href="http://news.li3.me">News</a><a href="../../../../../../../docs.html" class="active">Documentation</a><a href="../../../../../../../versions.html">Versions</a><a href="../../../../../../../present.html">Presentations</a><a href="../../../../../../../support.html">Community</a><a href="../../../../../../../development.html">Development</a></nav>	</div>
</header>							<nav class="crumbs">
	<ul itemscope itemtype="http://schema.org/BreadcrumbList">
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="1" />
							<a href="../../../../../../../docs.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">Documentation</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="2" />
							<a href="../../../lithium.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">Framework API (1.1.x)</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="3" />
							<a href="../../../lithium.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">lithium</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="4" />
							<a href="../../data.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">data</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="5" />
							<a href="../model.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">model</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="6" />
							<span itemscope itemprop="item" itemtype="http://schema.org/Thing">
					<span itemprop="name">Query</span>
				</span>
					</li>
		</ul>
</nav>						<div id="content">
				<article class="apis-view has-aside-right">

	<nav class="aside aside-right">
			<h3 class="h-gamma">Contents</h3>
		<ul>
			<li class="nav-up"><a href="../model.html" rel="up">../</a>		</ul>
	
													
						<h3 class="h-gamma">Methods</h3>
			<ul>
												<li class="method public">
				<a href="./Query::__construct().html">__construct()</a>												<li class="method protected">
				<a href="./Query::_init().html">_init()</a>												<li class="method public">
				<a href="./Query::map().html">map()</a>												<li class="method public">
				<a href="./Query::calculate().html">calculate()</a>												<li class="method public">
				<a href="./Query::model().html">model()</a>												<li class="method public">
				<a href="./Query::conditions().html">conditions()</a>												<li class="method public">
				<a href="./Query::having().html">having()</a>												<li class="method public">
				<a href="./Query::fields().html">fields()</a>												<li class="method public">
				<a href="./Query::limit().html">limit()</a>												<li class="method public">
				<a href="./Query::offset().html">offset()</a>												<li class="method public">
				<a href="./Query::page().html">page()</a>												<li class="method public">
				<a href="./Query::order().html">order()</a>												<li class="method public">
				<a href="./Query::group().html">group()</a>												<li class="method public">
				<a href="./Query::comment().html">comment()</a>												<li class="method public">
				<a href="./Query::entity().html">entity()</a>												<li class="method public">
				<a href="./Query::data().html">data()</a>												<li class="method public">
				<a href="./Query::relationships().html">relationships()</a>												<li class="method public">
				<a href="./Query::joins().html">joins()</a>												<li class="method public">
				<a href="./Query::export().html">export()</a>												<li class="method public">
				<a href="./Query::applyStrategy().html">applyStrategy()</a>												<li class="method protected">
				<a href="./Query::_exportData().html">_exportData()</a>												<li class="method public">
				<a href="./Query::schema().html">schema()</a>												<li class="method public">
				<a href="./Query::alias().html">alias()</a>												<li class="method public">
				<a href="./Query::paths().html">paths()</a>												<li class="method public">
				<a href="./Query::models().html">models()</a>												<li class="method public">
				<a href="./Query::__call().html">__call()</a>												<li class="method public">
				<a href="./Query::respondsTo().html">respondsTo()</a>												<li class="method protected">
				<a href="./Query::_entityConditions().html">_entityConditions()</a>												<li class="method public">
				<a href="./Query::childs().html">childs()</a>												<li class="method public inherited">
				<a href="../../core/Object::invokeMethod().html">invokeMethod()</a>												<li class="method public inherited">
				<a href="../../core/Object::__set_state().html">__set_state()</a>												<li class="method protected inherited">
				<a href="../../core/Object::_instance().html">_instance()</a>												<li class="method protected inherited">
				<a href="../../core/Object::_parents().html">_parents()</a>												<li class="method protected inherited">
				<a href="../../core/Object::_stop().html">_stop()</a>												<li class="method public deprecated inherited">
				<a href="../../core/Object::applyFilter().html">applyFilter()</a>												<li class="method protected deprecated inherited">
				<a href="../../core/Object::_filter().html">_filter()</a>							</ul>
								<h3 class="h-gamma">Properties</h3>
			<ul>
												<li class="property protected">
				<a href="./Query::$_map.html">$_map</a>												<li class="property protected">
				<a href="./Query::$_entity.html">$_entity</a>												<li class="property protected">
				<a href="./Query::$_data.html">$_data</a>												<li class="property protected">
				<a href="./Query::$_schema.html">$_schema</a>												<li class="property protected">
				<a href="./Query::$_classes.html">$_classes</a>												<li class="property protected">
				<a href="./Query::$_fields.html">$_fields</a>												<li class="property protected">
				<a href="./Query::$_alias.html">$_alias</a>												<li class="property protected">
				<a href="./Query::$_paths.html">$_paths</a>												<li class="property protected">
				<a href="./Query::$_models.html">$_models</a>												<li class="property protected">
				<a href="./Query::$_autoConfig.html">$_autoConfig</a>												<li class="property protected">
				<a href="./Query::$_initializers.html">$_initializers</a>												<li class="property protected">
				<a href="./Query::$_built.html">$_built</a>												<li class="property protected inherited">
				<a href="../../core/Object::$_config.html">$_config</a>												<li class="property protected inherited">
				<a href="../../core/Object::$_parents.html">$_parents</a>												<li class="property protected deprecated inherited">
				<a href="../../core/Object::$_methodFilters.html">$_methodFilters</a>							</ul>
						</nav>
	<div class="body">
			<h1 class="h-alpha">
		<a href="../../../lithium.html" class="symbol-segment">lithium</a>\<a href="../../data.html" class="symbol-segment">data</a>\<a href="../model.html" class="symbol-segment">model</a>\Query		</h1>

		<section class="under">
													<div class="extends">
					<span class="extends__title">Extends</span>
											<a href="../../core/Object.html" class="extends__symbol">lithium\core\Object</a>									</div>
									<div class="tags">
																<span class="tag">class</span>
			</div>
		</section>

					
			<section>
									<div class="summary">
						<p>The <code>Query</code> class acts as a container for all information necessary to perform a particular
database operation. Each <code>Query</code> object instance has a type, which is usually one of <code>'create'</code>,
<code>'read'</code>, <code>'update'</code> or <code>'delete'</code>.</p>
					</div>
				
									<div class="description">
						<p>Because of this, <code>Query</code> objects are the primary method of communication between <code>Model</code> classes
and backend data sources. This helps to keep APIs abstract and flexible, since a model is only
required to call a single method against its backend. Since the <code>Query</code> object simply acts as a
structured data container, each backend can choose how to operate on the data the <code>Query</code>
contains. See each class method for more details on what data this class supports.</p>
					</div>
							</section>

			
			
			
						<section id="related">
				<h3 class="h-beta">Related</h3>
				<ul class="related">
									<li><a href="../Model.html">lithium\data\Model</a>									<li><a href="../Source.html">lithium\data\Source</a>								</ul>
			</section>
			
			
			
						<section id="source" class="section">
				<h3 class="h-beta">Source</h3>
				<div id="source" class="source-display">
					<div class="source-wrapper">
						<pre class="source-code"><code class="language-php">class Query extends \lithium\core\Object {

	/**
	 * Array containing mappings of relationship and field names, which allow database results to
	 * be mapped to the correct objects.
	 *
	 * @var array
	 */
	protected $_map = [];

	/**
	 * If a `Query` is bound to a `Record` or `Document` object (i.e. for a `&#039;create&#039;` or
	 * `&#039;update&#039;` query).
	 *
	 * @var object
	 */
	protected $_entity = null;

	/**
	 * An array of data used in a write context. Only used if no binding object is present in the
	 * `$_entity` property.
	 *
	 * @var array
	 */
	protected $_data = [];

	/**
	 * A query can be assigned its own custom schema object, using the `schema()` method. If this
	 * is not assigned, then the model associated with the query will be used to get the schema
	 * information.
	 *
	 * @var object
	 */
	protected $_schema = null;

	/**
	 * Classes used by `Query`.
	 *
	 * @var array
	 */
	protected $_classes = [
		&#039;schema&#039; =&gt; &#039;lithium\data\Schema&#039;
	];

	/**
	 * The query&#039;s fields
	 *
	 * @see lithium\data\model\Query::fields()
	 * @var array
	 */
	protected $_fields = [0 =&gt; [], 1 =&gt; []];

	/**
	 * Count the number of identical models in a query for building
	 * unique aliases
	 *
	 * @see lithium\data\model\Query::alias()
	 * @var array
	 */
	protected $_alias = [];

	/**
	 * Map beetween generated aliases and corresponding relation paths
	 *
	 * @see lithium\data\model\Query::alias()
	 * @var array
	 */
	protected $_paths = [];

	/**
	 * Map beetween generated aliases and corresponding models.
	 *
	 * @see lithium\data\model\Query::alias()
	 * @var array
	 */
	protected $_models = [];

	/**
	 * Auto configuration properties.
	 *
	 * @var array
	 */
	protected $_autoConfig = [&#039;map&#039;];

	/**
	 * Initialization methods on construct
	 *
	 * @var array
	 */
	protected $_initializers = [
		&#039;model&#039;, &#039;entity&#039;, &#039;conditions&#039;, &#039;having&#039;, &#039;group&#039;, &#039;order&#039;,
		&#039;limit&#039;, &#039;offset&#039;, &#039;page&#039;, &#039;data&#039;, &#039;calculate&#039;, &#039;schema&#039;, &#039;comment&#039;
	];

	/**
	 * Boolean indicate if the query is built or not
	 *
	 * @var string
	 */
	protected $_built = false;

	/**
	 * Constructor, which initializes the default values this object supports. Even though only
	 * a specific list of configuration parameters is available by default, the `Query` object
	 * uses the `__call()` method to implement automatic getters and setters for any arbitrary
	 * piece of data.
	 *
	 * This means that any information may be passed into the constructor may be used by the
	 * backend data source executing the query (or ignored, if support is not implemented).
	 * This is useful if, for example, you wish to extend a core data source and implement
	 * custom functionality.
	 *
	 * @param array $config Available configuration options are:
	 *        - `&#039;type&#039;` _string_: The type of the query (`read`, `create`, `update`, `delete`).
	 *        - `&#039;mode&#039;` _string_: `JOIN` mode for a join query.
	 *        - `&#039;entity&#039;` _object_: The base entity to query on. If set `&#039;model&#039;` is optionnal.
	 *        - `&#039;model&#039;` _string_: The base model to query on.
	 *        - `&#039;source&#039;` _string_: The name of the table/collection. Unnecessary
	 *          if `model` is set.
	 *        - `&#039;alias&#039;` _string_: Alias for the source. Unnecessary if `model` is set.
	 *        - `&#039;schema&#039;` _object_: A schema model. Unnecessary if `model` is set.
	 *        - `&#039;fields&#039;` _array_: The fields to retreive.
	 *        - `&#039;conditions&#039;` _array_: The conditions of the queries
	 *        - `&#039;having&#039;` _array_: The having conditions of the queries
	 *        - `&#039;group&#039;` _string_: The group by parameter.
	 *        - `&#039;order&#039;` _string_: The order by parameter.
	 *        - `&#039;limit&#039;` _string_: The limit parameter.
	 *        - `&#039;offset&#039;` _string_: The offset of the `limit` options.
	 *        - `&#039;page&#039;` _string_: Convenience parameter for setting the `offset`:
	 *          `offset` = `page` * `limit`.
	 *        - `&#039;with&#039;` _array_: Contain dependencies. Works only if `model` is set.
	 *        - `&#039;joins&#039;` _array_: Contain manual join dependencies.
	 *        - `&#039;data&#039;` _array_: Datas for update queries.
	 *        - `&#039;whitelist&#039;` _array_: Allowed fields for updating queries.
	 *        - `&#039;calculate&#039;` _string_: Alias name of the count.
	 *        - `&#039;comment&#039;` _string_: Comment for the query.
	 *        - `&#039;map&#039;` _object_: Unnecessary if `model` is set.
	 *        - `&#039;relationships&#039;` _array_: Unnecessary if `model` is set.
	 * @return void
	 */
	public function __construct(array $config = []) {
		$defaults = [
			&#039;type&#039; =&gt; &#039;read&#039;,
			&#039;mode&#039; =&gt; null,
			&#039;model&#039; =&gt; null,
			&#039;entity&#039; =&gt; null,
			&#039;source&#039; =&gt; null,
			&#039;alias&#039; =&gt; null,
			&#039;fields&#039; =&gt; [],
			&#039;conditions&#039; =&gt; [],
			&#039;having&#039; =&gt; [],
			&#039;group&#039; =&gt; null,
			&#039;order&#039; =&gt; null,
			&#039;limit&#039; =&gt; null,
			&#039;offset&#039; =&gt; null,
			&#039;page&#039; =&gt; null,
			&#039;with&#039; =&gt; [],
			&#039;joins&#039; =&gt; [],
			&#039;data&#039; =&gt; [],
			&#039;whitelist&#039; =&gt; [],
			&#039;calculate&#039; =&gt; null,
			&#039;schema&#039; =&gt; null,
			&#039;comment&#039; =&gt; null,
			&#039;map&#039; =&gt; [],
			&#039;relationships&#039; =&gt; []
		];
		parent::__construct($config + $defaults);
	}

	protected function _init() {
		parent::_init();

		foreach ($this-&gt;_initializers as $key) {
			if (($value = $this-&gt;_config[$key]) !== null) {
				$this-&gt;_config[$key] = is_array($value) ? [] : null;
				$this-&gt;{$key}($value);
			}
		}
		if ($list = $this-&gt;_config[&#039;whitelist&#039;]) {
			$this-&gt;_config[&#039;whitelist&#039;] = array_combine($list, $list);
		}
		if ($this-&gt;_entity &amp;&amp; !$this-&gt;_config[&#039;model&#039;]) {
			$this-&gt;model($this-&gt;_entity-&gt;model());
		}
		if ($this-&gt;_config[&#039;with&#039;]) {
			if (!$model = $this-&gt;model()) {
				throw new ConfigException(&quot;The `&#039;with&#039;` option needs a valid binded model.&quot;);
			}
			$this-&gt;_config[&#039;with&#039;] = Set::normalize($this-&gt;_config[&#039;with&#039;]);
		}
		if ($model = $this-&gt;model()) {
			$this-&gt;alias($this-&gt;_config[&#039;alias&#039;] ?: $model::meta(&#039;name&#039;));
		}
		$this-&gt;fields($this-&gt;_config[&#039;fields&#039;]);

		unset($this-&gt;_config[&#039;entity&#039;], $this-&gt;_config[&#039;init&#039;]);
	}

	/**
	 * Generates a schema map of the query&#039;s result set, where the keys are aliases, and the values
	 * are arrays of field names.
	 *
	 * @param array $map
	 * @return array
	 */
	public function map($map = null) {
		if ($map !== null) {
			$this-&gt;_map = $map;
			return $this;
		}
		return $this-&gt;_map;
	}

	/**
	 * Accessor method for `Query` calculate values.
	 *
	 * @param string $calculate Value for calculate config setting.
	 * @return mixed Current calculate config value.
	 */
	public function calculate($calculate = null) {
		if ($calculate) {
			$this-&gt;_config[&#039;calculate&#039;] = $calculate;
			return $this;
		}
		return $this-&gt;_config[&#039;calculate&#039;];
	}

	/**
	 * Set or get the associated model.
	 *
	 * Will also set the source table, i.e. `$this-&gt;_config[&#039;source&#039;]` when setting the model.
	 *
	 * @param string|null $model Name of model to use, or `null` to retrieve current one.
	 * @return string|Query Either the current model name in use when $model is `null`,
	 *         or the query itself when setting the model name.
	 */
	public function model($model = null) {
		if (!$model) {
			return $this-&gt;_config[&#039;model&#039;];
		}
		$this-&gt;_config[&#039;model&#039;] = $model;
		$this-&gt;_config[&#039;source&#039;] = $this-&gt;_config[&#039;source&#039;] ?: $model::meta(&#039;source&#039;);

		return $this;
	}

	/**
	 * Set or append to existing conditions, or get current conditions.
	 *
	 * When getting current conditions and none are configured for the query,
	 * will ask the bound entity for its conditions instead.
	 *
	 * @param string|array|null $conditions Condition/s to append to existing conditions.
	 *        Provide `null` to get current conditions.
	 * @return string|Query Either the currrent conditions when $conditions is
	 *         `null` or the query itself when setting the conditions.
	 */
	public function conditions($conditions = null) {
		if (!$conditions) {
			return $this-&gt;_config[&#039;conditions&#039;] ?: $this-&gt;_entityConditions();
		}
		$this-&gt;_config[&#039;conditions&#039;] = array_merge(
			(array) $this-&gt;_config[&#039;conditions&#039;], (array) $conditions
		);
		return $this;
	}

	/**
	 * Set and get _having_.
	 *
	 * @param mixed $having String or array to append to existing having.
	 * @return string|Query Either the currrent _having_ when $having is
	 *         `null` or the query itself when setting _having_.
	 */
	public function having($having = null) {
		if (!$having) {
			return $this-&gt;_config[&#039;having&#039;];
		}
		$this-&gt;_config[&#039;having&#039;] = array_merge(
			(array) $this-&gt;_config[&#039;having&#039;], (array) $having
		);
		return $this;
	}

	/**
	 * Set, get or reset fields option for query.
	 *
	 * Usage:
	 * ```
	 * // to add a field
	 * $query-&gt;fields(&#039;created&#039;);
	 *
	 * // to add several fields
	 * $query-&gt;fields([&#039;title&#039;,&#039;body&#039;,&#039;modified&#039;]);
	 *
	 * // to reset fields to none
	 * $query-&gt;fields(false);
	 * // should be followed by a 2nd call to fields with required fields
	 * ```
	 *
	 * @param mixed $fields string, array or `false`
	 * @param boolean $overwrite If `true`, existing fields will be removed before adding `$fields`.
	 * @return array Returns an array containing all fields added to the query.
	 */
	public function fields($fields = null, $overwrite = false) {
		if ($fields === false || $overwrite) {
			$this-&gt;_fields = [0 =&gt; [], 1 =&gt; []];
		}
		if ($fields === null) {
			return array_merge(array_keys($this-&gt;_fields[1]), $this-&gt;_fields[0]);
		}
		if (!$fields) {
			return $this;
		}
		foreach ((array) $fields as $key =&gt; $field) {
			if (is_string($field)) {
				$this-&gt;_fields[1][$field] = true;
			} elseif (is_array($field) &amp;&amp; !is_numeric($key)) {
				foreach ($field as &amp;$value) {
					$value = &quot;{$key}.{$value}&quot;;
				}
				$this-&gt;fields($field);
			} else {
				$this-&gt;_fields[0][] = $field;
			}
		}
		return $this;
	}

	/**
	 * Set or get the limit for the amount of results to return.
	 *
	 * @param integer|boolean $limit An integer indicating the number of results to limit or
	 *        `false` to employ no limit at all. Or `null` to retrieve the current limit.
	 * @return integer|null|Query Either the currrent limit when $limit is
	 *         `null` or the query itself when setting the limit or providing `false`.
	 */
	public function limit($limit = null) {
		if ($limit) {
			$this-&gt;_config[&#039;limit&#039;] = (integer) $limit;
			return $this;
		}
		if ($limit === false) {
			$this-&gt;_config[&#039;limit&#039;] = null;
			return $this;
		}
		return $this-&gt;_config[&#039;limit&#039;];
	}

	/**
	 * Set and get method for query&#039;s offset, i.e. which records to get
	 *
	 * @param integer|null $offset
	 * @return integer|\lithium\data\Query
	 */
	public function offset($offset = null) {
		if ($offset !== null) {
			$this-&gt;_config[&#039;offset&#039;] = (integer) $offset;
			return $this;
		}
		return $this-&gt;_config[&#039;offset&#039;];
	}

	/**
	 * Set and get method for page, in relation to limit, of which records to get
	 *
	 * @param integer|null $page
	 * @return integer|\lithium\data\Query
	 */
	public function page($page = null) {
		if ($page) {
			$this-&gt;_config[&#039;page&#039;] = $page = ((integer) $page ?: 1);
			$this-&gt;offset(($page - 1) * $this-&gt;_config[&#039;limit&#039;]);
			return $this;
		}
		return $this-&gt;_config[&#039;page&#039;];
	}

	/**
	 * Set and get method for the query&#039;s order specification.
	 *
	 * @param array|string|null $order
	 * @return array|\lithium\data\Query
	 */
	public function order($order = null) {
		if ($order) {
			$this-&gt;_config[&#039;order&#039;] = $order;
			return $this;
		}
		return $this-&gt;_config[&#039;order&#039;];
	}

	/**
	 * Set and get method for the `Query` group config setting.
	 *
	 * @param string|array|null $group
	 * @return array|null|\lithium\data\Query
	 */
	public function group($group = null) {
		if ($group) {
			$this-&gt;_config[&#039;group&#039;] = $group;
			return $this;
		}
		if ($group === false) {
			$this-&gt;_config[&#039;group&#039;] = null;
			return $this;
		}
		return $this-&gt;_config[&#039;group&#039;];
	}

	/**
	 * Set and get method for current query&#039;s comment.
	 *
	 * Comment will have no effect on query, but will be passed along so data source can log it.
	 *
	 * @param string|null $comment
	 * @return string|\lithium\data\Query
	 */
	public function comment($comment = null) {
		if ($comment) {
			$this-&gt;_config[&#039;comment&#039;] = $comment;
			return $this;
		}
		return $this-&gt;_config[&#039;comment&#039;];
	}

	/**
	 * Set and get method for the query&#039;s entity instance.
	 *
	 * @param object $entity Reference to the query&#039;s current entity object.
	 * @return \lithium\data\Query|\lithium\data\Entity
	 */
	public function &amp;entity(&amp;$entity = null) {
		if ($entity) {
			$this-&gt;_entity = $entity;
			return $this;
		}
		return $this-&gt;_entity;
	}

	/**
	 * Set and get method for the query&#039;s record&#039;s data.
	 *
	 * @param array $data if set, will set given array.
	 * @return array Empty array if no data, array of data if the record has it.
	 */
	public function data($data = []) {
		$bind =&amp; $this-&gt;_entity;

		if ($data) {
			$bind ? $bind-&gt;set($data) : $this-&gt;_data = array_merge($this-&gt;_data, $data);
			return $this;
		}
		$data = $bind ? $bind-&gt;data() : $this-&gt;_data;
		return ($list = $this-&gt;_config[&#039;whitelist&#039;]) ? array_intersect_key($data, $list) : $data;
	}

	/**
	 * Set and get the relationships.
	 *
	 * @param string $relpath A dotted path.
	 * @param array $config the config array to set.
	 * @return mixed The relationships array or a relationship array if `$relpath` is set. Returns
	 *         `null` if a join doesn&#039;t exist.
	 * @throws InvalidArgumentException
	 */
	public function relationships($relpath = null, $config = null) {
		if ($config) {
			if (!$relpath) {
				throw new InvalidArgumentException(&quot;The relation dotted path is empty.&quot;);
			}
			if (isset($config[&#039;model&#039;]) &amp;&amp; isset($config[&#039;alias&#039;])) {
				$this-&gt;_models[$config[&#039;alias&#039;]] = $config[&#039;model&#039;];
			}
			$this-&gt;_config[&#039;relationships&#039;][$relpath] = $config;
			return $this;
		}
		if (!$relpath) {
			return $this-&gt;_config[&#039;relationships&#039;];
		}
		if (isset($this-&gt;_config[&#039;relationships&#039;][$relpath])) {
			return $this-&gt;_config[&#039;relationships&#039;][$relpath];
		}
	}

	/**
	 * Set and get the joins
	 *
	 * @param string $name Optional name of join. Unless two parameters are passed, this parameter
	 *               is regonized as `$join`.
	 * @param object|string $join A single query object or an array of query objects
	 * @return mixed The joins array or a join array if `$name` is set. Returns `null` if a join
	 *         doesn&#039;t exist.
	 */
	public function joins($name = null, $join = null) {
		if (is_array($name)) {
			$join = $name;
			$name = null;
		}
		if ($join) {
			if (!$name) {
				$this-&gt;_config[&#039;joins&#039;][] = $join;
			} else {
				$this-&gt;_config[&#039;joins&#039;][$name] = $join;
			}
			return $this;
		}
		if (!$name) {
			return $this-&gt;_config[&#039;joins&#039;];
		}
		if (isset($this-&gt;_config[&#039;joins&#039;][$name])) {
			return $this-&gt;_config[&#039;joins&#039;][$name];
		}
	}

	/**
	 * Convert the query&#039;s properties to the data sources&#039; syntax and return it as an array.
	 *
	 * @param \lithium\data\Source $source Instance of the data source to use for conversion.
	 * @param array $options Options to use when exporting the data.
	 * @return array Returns an array containing a data source-specific representation of a query.
	 */
	public function export(Source $source, array $options = []) {
		$defaults = [&#039;keys&#039; =&gt; []];
		$options += $defaults;

		if ($options[&#039;keys&#039;]) {
			$keys = array_flip($options[&#039;keys&#039;]);
		} else {
			$keys =&amp; $this-&gt;_config;
		}
		list($copy, $apply) = Set::slice($keys, $source-&gt;methods());

		if (isset($keys[&#039;with&#039;])) {
			$this-&gt;applyStrategy($source);
		}

		foreach ($apply as $item =&gt; $value) {
			$results[$item] = $source-&gt;{$item}($this-&gt;{$item}(), $this);
		}
		foreach ($copy as $item =&gt; $value) {
			$results[$item] = $this-&gt;_config[$item];
		}

		if (array_key_exists(&#039;data&#039;, $keys)) {
			$results[&#039;data&#039;] = $this-&gt;_exportData();
		}
		if (array_key_exists(&#039;source&#039;, $keys)) {
			$results[&#039;source&#039;] = $source-&gt;name($results[&#039;source&#039;]);
		}

		if (!isset($results[&#039;fields&#039;])) {
			return $results;
		}
		$created = [&#039;fields&#039;, &#039;values&#039;];

		if (is_array($results[&#039;fields&#039;]) &amp;&amp; array_keys($results[&#039;fields&#039;]) == $created) {
			$results = $results[&#039;fields&#039;] + $results;
		}
		return $results;
	}

	/**
	 * Helper method used by `export()` which delegate the query generation to the data source.
	 *
	 * @param \lithium\data\Source $source Instance of the data source to use for conversion.
	 */
	public function applyStrategy(Source $source) {
		if ($this-&gt;_built) {
			return;
		}
		$this-&gt;_built = true;
		if (!$this-&gt;_config[&#039;with&#039;]) {
			return;
		}
		$options = [];
		if (isset($this-&gt;_config[&#039;strategy&#039;])) {
			$options[&#039;strategy&#039;] = $this-&gt;_config[&#039;strategy&#039;];
		}
		$source-&gt;applyStrategy($options, $this);
	}

	/**
	 * Helper method used by `export()` to extract the data either from a bound entity, or from
	 * passed configuration, and filter it through a configured whitelist, if present.
	 *
	 * @return array
	 */
	protected function _exportData() {
		$data = $this-&gt;_entity ? $this-&gt;_entity-&gt;export() : $this-&gt;_data;

		if (!$list = $this-&gt;_config[&#039;whitelist&#039;]) {
			return $data;
		}
		$list = array_combine($list, $list);

		if (!$this-&gt;_entity) {
			return array_intersect_key($data, $list);
		}

		foreach ($data as $type =&gt; $values) {
			if (!is_array($values)) {
				continue;
			}
			$data[$type] = array_intersect_key($values, $list);
		}
		return $data;
	}

	public function schema($field = null) {
		if (is_object($field)) {
			$this-&gt;_schema = $field;
			return;
		}
		if ($schema = $this-&gt;_schema) {
			return $field ? $schema[$field] : $schema;
		}
		if ($model = $this-&gt;model()) {
			return $model::schema($field);
		} else {
			return $this-&gt;_instance(&#039;schema&#039;);
		}
	}

	/**
	 * Get or Set a unique alias for the query or a query&#039;s relation if `$relpath` is set.
	 *
	 * @param mixed $alias The value of the alias to set for the passed `$relpath`. For getting an
	 *        alias value set alias to `true`.
	 * @param string $relpath A dotted relation name or `null` for identifying the query&#039;s model.
	 * @return string An alias value or `null` for an unexisting `$relpath` alias.
	 */
	public function alias($alias = true, $relpath = null) {
		if ($alias === true) {
			if (!$relpath) {
				return $this-&gt;_config[&#039;alias&#039;];
			}
			$return = array_search($relpath, $this-&gt;_paths);
			return $return ?: null;
		}

		if ($relpath === null) {
			$this-&gt;_config[&#039;alias&#039;] = $alias;
		}

		if ($relpath === null &amp;&amp; ($model = $this-&gt;_config[&#039;model&#039;])) {
			$this-&gt;_models[$alias] = $model;
		}

		$relpath = (string) $relpath;
		unset($this-&gt;_paths[array_search($relpath, $this-&gt;_paths)]);

		if (!$alias &amp;&amp; $relpath) {
			$last = strrpos($relpath, &#039;.&#039;);
			$alias = $last ? substr($relpath, $last + 1) : $relpath;
		}

		if (isset($this-&gt;_alias[$alias])) {
			$this-&gt;_alias[$alias]++;
			$alias .= &#039;__&#039; . $this-&gt;_alias[$alias];
		} else {
			$this-&gt;_alias[$alias] = 1;
		}

		$this-&gt;_paths[$alias] = $relpath;
		return $alias;
	}

	/**
	 * Return the generated aliases mapped to their relation path
	 *
	 * @param \lithium\data\Source $source Instance of the data source to use for conversion.
	 * @return array Map between aliases and their corresponding dotted relation paths.
	 */
	public function paths(Source $source = null) {
		if ($source) {
			$this-&gt;applyStrategy($source);
		}
		return $this-&gt;_paths;
	}

	/**
	 * Return the generated aliases mapped to their corresponding model
	 *
	 * @param \lithium\data\Source $source Instance of the data source to use for conversion.
	 * @return array Map between aliases and their corresponding fully-namespaced model names.
	 */
	public function models(Source $source = null) {
		if ($source) {
			$this-&gt;applyStrategy($source);
		}
		return $this-&gt;_models;
	}

	/**
	 * Gets or sets a custom query field which does not have an accessor method.
	 *
	 * @param string $method Query part.
	 * @param array $params Query parameters.
	 * @return mixed Returns the value as set in the `Query` object&#039;s constructor.
	 */
	public function __call($method, array $params = []) {
		if ($params) {
			$this-&gt;_config[$method] = current($params);
			return $this;
		}
		return isset($this-&gt;_config[$method]) ? $this-&gt;_config[$method] : null;
	}

	/**
	 * Determines if a given method can be called.
	 *
	 * @param string $method Name of the method.
	 * @param boolean $internal Provide `true` to perform check from inside the
	 *                class/object. When `false` checks also for public visibility;
	 *                defaults to `false`.
	 * @return boolean Returns `true` if the method can be called, `false` otherwise.
	 */
	public function respondsTo($method, $internal = false) {
		return isset($this-&gt;_config[$method]) || parent::respondsTo($method, $internal);
	}

	/**
	 * Will return a find first condition on the associated model if a record is connected.
	 * Called by conditions when it is called as a get and no condition is set.
	 *
	 * @return array Returns an array in the following format:
	 *         `([model&#039;s primary key&#039;] =&gt; [that key set in the record])`.
	 */
	protected function _entityConditions() {
		if (!$this-&gt;_entity || !($model = $this-&gt;_config[&#039;model&#039;])) {
			return [];
		}
		$key = $model::key($this-&gt;_entity-&gt;data());

		if (!$key &amp;&amp; $this-&gt;type() !== &#039;create&#039;) {
			throw new ConfigException(&#039;No matching primary key found.&#039;);
		}
		if (is_array($key)) {
			return $key;
		}

		$key = $model::meta(&#039;key&#039;);
		$val = $this-&gt;_entity-&gt;{$key};
		return $val ? [$key =&gt; $val] : [];
	}

	/**
	 * Get/set sub queries for the query.
	 *
	 * The getter must be called after an export since the sub queries are built
	 * during the export according the export&#039;s `mode` option and the query `with` option.
	 *
	 * @see lithium\data\model\Query::export()
	 * @param string $relpath a dotted relation path
	 * @param string $query a query instance
	 * @return mixed
	 */
	public function childs($relpath = null, $query = null) {
		if (!$model = $this-&gt;model()) {
			throw new ConfigException(&quot;No binded model.&quot;);
		}
		if ($query) {
			$this-&gt;_childs[$relpath] = $query;
			return $this;
		}
		return $this-&gt;_childs;
	}
}</code></pre>
					</div>
				</div>
			</section>
							</div>
	</article>			</div>
		</div>
		<footer class="main">
	<div class="area"></div>
	<div class="area"></div>
	<div class="area"></div>
	<div class="area"></div>

	<div class="social">
		<a href="https://github.com/unionofrad" target="new">GitHub</a>		<span class="separator">/</span>
		<a href="https://twitter.com/unionofrad" target="new">Twitter</a>		<span class="separator">/</span>
		<a href="http://www.reddit.com/r/li3" target="new">Reddit</a>		<span class="separator">/</span>
		<a href="https://stackoverflow.com/questions/tagged/lithium" target="new">Stack Overflow</a>	</div>
	<div class="testimonial">
		<img src="../../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/img/testimonials/10.png" alt="Testimonial Image" />		<p>I think it's time you started<br />
writing better code.</p>
	</div>
	<div class="copyright">
		Pretty much everything is (c) 2009-2024 and beyond, the <a href="http://unionofrad.org">Union of RAD</a>.	</div>
</footer>	</body>
</body>
</html>

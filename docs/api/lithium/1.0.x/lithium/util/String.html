<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />	<title>lithium\util\String – Framework API v1.0.x – Documentation – li3 PHP-Framework</title>
		<link rel="stylesheet" href="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/reset.css" />
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro:400,700,400italic,700italic" />
	<link rel="stylesheet" href="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/u1m.css" />
	<link rel="stylesheet" href="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/li3_docs.css" />
	<link rel="stylesheet" href="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/css/highlight.css" />
	
	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
	<script src="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/js/base.js"></script>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.js"></script>
	
	
	<link rel="icon" href="../../../../../../assets/ico/site.png">

		<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-11048416-4', 'auto');
	  ga('send', 'pageview');
	</script>
	</head>
<body class="layout-default li3-docs">
		<div id="container">
			<header class="main">
	<div class="left">
		<h1><a href="../../../../../../index.html" class="li3-logo">li3</a></h1>
	</div>
	<div class="right">
		<nav class="main-nav"><a href="http://news.li3.me">News</a><a href="../../../../../../docs.html" class="active">Documentation</a><a href="../../../../../../versions.html">Versions</a><a href="../../../../../../present.html">Presentations</a><a href="../../../../../../support.html">Community</a><a href="../../../../../../development.html">Development</a></nav>	</div>
</header>							<nav class="crumbs">
	<ul itemscope itemtype="http://schema.org/BreadcrumbList">
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="1" />
							<a href="../../../../../../docs.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">Documentation</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="2" />
							<a href="../../lithium.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">Framework API (1.0.x)</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="3" />
							<a href="../../lithium.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">lithium</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="4" />
							<a href="../util.html" itemscope itemprop="item" itemtype="http://schema.org/Thing"><span itemprop="name">util</span></a>
					</li>
			<li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
			<meta itemprop="position" content="5" />
							<span itemscope itemprop="item" itemtype="http://schema.org/Thing">
					<span itemprop="name">String</span>
				</span>
					</li>
		</ul>
</nav>						<div id="content">
				<article class="apis-view has-aside-right">

	<nav class="aside aside-right">
			<h3 class="h-gamma">Contents</h3>
		<ul>
			<li class="nav-up"><a href="../util.html" rel="up">../</a>		</ul>
	
													
						<h3 class="h-gamma">Methods</h3>
			<ul>
												<li class="method public">
				<a href="./String::uuid().html">uuid()</a>												<li class="method public">
				<a href="./String::random().html">random()</a>												<li class="method protected">
				<a href="./String::_source().html">_source()</a>												<li class="method public">
				<a href="./String::hash().html">hash()</a>												<li class="method public">
				<a href="./String::compare().html">compare()</a>												<li class="method public">
				<a href="./String::insert().html">insert()</a>												<li class="method public">
				<a href="./String::clean().html">clean()</a>												<li class="method public">
				<a href="./String::extract().html">extract()</a>												<li class="method public">
				<a href="./String::tokenize().html">tokenize()</a>							</ul>
								<h3 class="h-gamma">Properties</h3>
			<ul>
												<li class="property protected">
				<a href="./String::$_source.html">$_source</a>							</ul>
								<h3 class="h-gamma">Constants</h3>
			<ul>
												<li class="constant ">
				<a href="./String::UUID_CLEAR_VER.html">UUID_CLEAR_VER</a>												<li class="constant ">
				<a href="./String::UUID_VERSION_4.html">UUID_VERSION_4</a>												<li class="constant ">
				<a href="./String::UUID_CLEAR_VAR.html">UUID_CLEAR_VAR</a>												<li class="constant ">
				<a href="./String::UUID_VAR_RFC.html">UUID_VAR_RFC</a>												<li class="constant ">
				<a href="./String::ENCODE_BASE_64.html">ENCODE_BASE_64</a>							</ul>
			</nav>
	<div class="body">
			<h1 class="h-alpha">
		<a href="../../lithium.html" class="symbol-segment">lithium</a>\<a href="../util.html" class="symbol-segment">util</a>\String		</h1>

		<section class="under">
															<div class="tags">
																<span class="tag">class</span>
			</div>
		</section>

					
			<section>
									<div class="summary">
						<p>String manipulation utility class. Includes functionality for generating UUIDs,
{:tag} and regex replacement, and tokenization. Also includes a cryptographically-strong random
number generator, and a base64 encoder for use with DES and XDES.</p>
					</div>
				
							</section>

			
			
			
			
			
			
						<section id="source" class="section">
				<h3 class="h-beta">Source</h3>
				<div id="source" class="source-display">
					<div class="source-wrapper">
						<pre class="source-code"><code class="language-php">class String {

	/**
	 * UUID-related constant. Clears all bits of version byte (`00001111`).
	 */
	const UUID_CLEAR_VER = 15;

	/**
	 * UUID constant that sets the version bit for generated UUIDs (`01000000`).
	 */
	const UUID_VERSION_4 = 64;

	/**
	 * Clears relevant bits of variant byte (`00111111`).
	 */
	const UUID_CLEAR_VAR = 63;

	/**
	 * The RFC 4122 variant (`10000000`).
	 */
	const UUID_VAR_RFC = 128;

	/**
	 * Option flag used in `String::random()`.
	 */
	const ENCODE_BASE_64 = 1;

	/**
	 * A closure which, given a number of bytes, returns that amount of
	 * random bytes.
	 *
	 * @var \Closure
	 */
	protected static $_source;

	/**
	 * Generates an RFC 4122-compliant version 4 UUID.
	 *
	 * @return string The string representation of an RFC 4122-compliant, version 4 UUID.
	 * @link http://www.ietf.org/rfc/rfc4122.txt RFC 4122: UUID URN Namespace
	 */
	public static function uuid() {
		$uuid = static::random(16);
		$uuid[6] = chr(ord($uuid[6]) &amp; static::UUID_CLEAR_VER | static::UUID_VERSION_4);
		$uuid[8] = chr(ord($uuid[8]) &amp; static::UUID_CLEAR_VAR | static::UUID_VAR_RFC);

		return join(&#039;-&#039;, array(
			bin2hex(substr($uuid, 0, 4)),
			bin2hex(substr($uuid, 4, 2)),
			bin2hex(substr($uuid, 6, 2)),
			bin2hex(substr($uuid, 8, 2)),
			bin2hex(substr($uuid, 10, 6))
		));
	}

	/**
	 * Generates random bytes for use in UUIDs and password salts, using
	 * (when available) a cryptographically strong random number generator.
	 *
	 * ```
	 * $bits = String::random(8); // 64 bits
	 * $hex = bin2hex($bits); // [0-9a-f]+
	 * ```
	 *
	 * Optionally base64-encodes the resulting random string per the following. The
	 * alphabet used by `base64_encode()` is different than the one we should be using.
	 * When considering the meaty part of the resulting string, however, a bijection
	 * allows to go the from one to another. Given that we&#039;re working on random bytes, we
	 * can use safely use `base64_encode()` without losing any entropy.
	 *
	 * @param integer $bytes The number of random bytes to generate.
	 * @param array $options The options used when generating random bytes:
	 *              - `&#039;encode&#039;` _integer_: If specified, and set to `String::ENCODE_BASE_64`, the
	 *                resulting value will be base64-encoded, per the notes above.
	 * @return string Returns a string of random bytes.
	 */
	public static function random($bytes, array $options = array()) {
		$defaults = array(&#039;encode&#039; =&gt; null);
		$options += $defaults;

		$source = static::$_source ?: static::_source();
		$result = $source($bytes);

		if ($options[&#039;encode&#039;] !== static::ENCODE_BASE_64) {
			return $result;
		}
		return strtr(rtrim(base64_encode($result), &#039;=&#039;), &#039;+&#039;, &#039;.&#039;);
	}

	/**
	 * Initializes `String::$_source` using the best available random number generator.
	 *
	 * When available, `/dev/urandom` and COM gets used on *nix and
	 * [Windows systems](http://msdn.microsoft.com/en-us/library/aa388182%28VS.85%29.aspx?ppud=4),
	 * respectively.
	 *
	 * If all else fails, a Mersenne Twister gets used. (Strictly
	 * speaking, this fallback is inadequate, but good enough.)
	 *
	 * Note: Users restricting path access through the `open_basedir` INI setting,
	 * will need to include `/dev/urandom` into the list of allowed paths, as this
	 * method might read from `/dev/urandom`.
	 *
	 * @see lithium\util\String::$_source
	 * @return \Closure Returns a closure containing a random number generator.
	 */
	protected static function _source() {
		switch (true) {
			case isset(static::$_source):
				return static::$_source;
			case is_readable(&#039;/dev/urandom&#039;) &amp;&amp; $fp = fopen(&#039;/dev/urandom&#039;, &#039;rb&#039;):
				return static::$_source = function($bytes) use (&amp;$fp) {
					return fread($fp, $bytes);
				};
			case class_exists(&#039;COM&#039;, false):
				try {
					$com = new COM(&#039;CAPICOM.Utilities.1&#039;);
					return static::$_source = function($bytes) use ($com) {
						return base64_decode($com-&gt;GetRandom($bytes, 0));
					};
				} catch (Exception $e) {
				}
			default:
				return static::$_source = function($bytes) {
					$rand = &#039;&#039;;

					for ($i = 0; $i &lt; $bytes; $i++) {
						$rand .= chr(mt_rand(0, 255));
					}
					return $rand;
				};
		}
	}

	/**
	 * Uses PHP&#039;s hashing functions to create a hash of the string provided, using the options
	 * specified. The default hash algorithm is SHA-512.
	 *
	 * @link http://php.net/function.hash.php PHP Manual: `hash()`
	 * @link http://php.net/function.hash-hmac.php PHP Manual: `hash_hmac()`
	 * @link http://php.net/function.hash-algos.php PHP Manual: `hash_algos()`
	 * @param string $string The string to hash.
	 * @param array $options Supported options:
	 *        - `&#039;type&#039;` _string_: Any valid hashing algorithm. See the `hash_algos()` function to
	 *          determine which are available on your system.
	 *        - `&#039;salt&#039;` _string_: A _salt_ value which, if specified, will be prepended to the
	 *          string.
	 *        - `&#039;key&#039;` _string_: If specified `hash_hmac()` will be used to hash the string,
	 *          instead of `hash()`, with `&#039;key&#039;` being used as the message key.
	 *        - `&#039;raw&#039;` _boolean_: If `true`, outputs the raw binary result of the hash operation.
	 *          Defaults to `false`.
	 * @return string Returns a hashed string.
	 */
	public static function hash($string, array $options = array()) {
		$defaults = array(
			&#039;type&#039; =&gt; &#039;sha512&#039;,
			&#039;salt&#039; =&gt; false,
			&#039;key&#039; =&gt; false,
			&#039;raw&#039; =&gt; false
		);
		$options += $defaults;

		if ($options[&#039;salt&#039;]) {
			$string = $options[&#039;salt&#039;] . $string;
		}
		if ($options[&#039;key&#039;]) {
			return hash_hmac($options[&#039;type&#039;], $string, $options[&#039;key&#039;], $options[&#039;raw&#039;]);
		}
		return hash($options[&#039;type&#039;], $string, $options[&#039;raw&#039;]);
	}

	/**
	 * Compares two strings in constant time to prevent timing attacks.
	 *
	 * To successfully mitigate timing attacks and not leak the actual length of the known
	 * string, it is important that _both provided strings have the same length_ and that
	 * the _user-supplied string is passed as a second parameter_ rather than first.
	 *
	 * This function has the same signature and behavior as the native `hash_equals()` function
	 * and will use that function if available (PHP &gt;= 5.6).
	 *
	 * An E_USER_WARNING will be emitted when either of the supplied parameters is not a string.
	 *
	 * @link http://php.net/hash_equals
	 * @link http://codahale.com/a-lesson-in-timing-attacks/ More about timing attacks.
	 * @param string $known The string of known length to compare against.
	 * @param string $user The user-supplied string.
	 * @return boolean Returns a boolean indicating whether the two strings are equal.
	 */
	public static function compare($known, $user) {
		if (function_exists(&#039;hash_equals&#039;)) {
			return hash_equals($known, $user);
		}
		if (!is_string($known) || !is_string($user)) {
			trigger_error(&#039;Expected `$known` &amp; `$user` parameters to be strings.&#039;, E_USER_WARNING);
			return false;
		}

		if (($length = strlen($known)) !== strlen($user)) {
			return false;
		}
		for ($i = 0, $result = 0; $i &lt; $length; $i++) {
			$result |= ord($known[$i]) ^ ord($user[$i]);
		}
		return $result === 0;
	}

	/**
	 * Replaces variable placeholders inside a string with any given data. Each key
	 * in the `$data` array corresponds to a variable placeholder name in `$str`.
	 *
	 * Usage:
	 * ```
	 * String::insert(
	 *     &#039;My name is {:name} and I am {:age} years old.&#039;,
	 *     array(&#039;name&#039; =&gt; &#039;Bob&#039;, &#039;age&#039; =&gt; &#039;65&#039;)
	 * ); // returns &#039;My name is Bob and I am 65 years old.&#039;
	 * ```
	 *
	 * Please note that optimization have applied to this method and parts of the code
	 * may look like it can refactored or removed but in fact this is part of the applied
	 * optimization. Please check the history for this section of code before refactoring
	 *
	 * @param string $str A string containing variable place-holders.
	 * @param array $data A key, value array where each key stands for a place-holder variable
	 *                     name to be replaced with value.
	 * @param array $options Available options are:
	 *        - `&#039;after&#039;`: The character or string after the name of the variable place-holder
	 *          (defaults to `}`).
	 *        - `&#039;before&#039;`: The character or string in front of the name of the variable
	 *          place-holder (defaults to `&#039;{:&#039;`).
	 *        - `&#039;clean&#039;`: A boolean or array with instructions for `String::clean()`.
	 *        - `&#039;escape&#039;`: The character or string used to escape the before character or string
	 *          (defaults to `&#039;\&#039;`).
	 *        - `&#039;format&#039;`: A regular expression to use for matching variable place-holders
	 *          (defaults to `&#039;/(?&lt;!\\)\:%s/&#039;`. Please note that this option takes precedence over
	 *          all other options except `&#039;clean&#039;`.
	 * @return string
	 */
	public static function insert($str, array $data, array $options = array()) {
		$defaults = array(
			&#039;before&#039; =&gt; &#039;{:&#039;,
			&#039;after&#039; =&gt; &#039;}&#039;,
			&#039;escape&#039; =&gt; null,
			&#039;format&#039; =&gt; null,
			&#039;clean&#039; =&gt; false
		);
		$options += $defaults;
		$format = $options[&#039;format&#039;];

		if ($format === &#039;regex&#039; || (!$format &amp;&amp; $options[&#039;escape&#039;])) {
			$format = sprintf(
				&#039;/(?&lt;!%s)%s%%s%s/&#039;,
				preg_quote($options[&#039;escape&#039;], &#039;/&#039;),
				str_replace(&#039;%&#039;, &#039;%%&#039;, preg_quote($options[&#039;before&#039;], &#039;/&#039;)),
				str_replace(&#039;%&#039;, &#039;%%&#039;, preg_quote($options[&#039;after&#039;], &#039;/&#039;))
			);
		}

		if (!$format &amp;&amp; key($data) !== 0) {
			$replace = array();

			foreach ($data as $key =&gt; $value) {
				if (!is_scalar($value)) {
					if (is_object($value) &amp;&amp; method_exists($value, &#039;__toString&#039;)) {
						$value = (string) $value;
					} else {
						$value = &#039;&#039;;
					}
				}
				$replace[&quot;{$options[&#039;before&#039;]}{$key}{$options[&#039;after&#039;]}&quot;] = $value;
			}
			$str = strtr($str, $replace);
			return $options[&#039;clean&#039;] ? static::clean($str, $options) : $str;
		}

		if (strpos($str, &#039;?&#039;) !== false &amp;&amp; isset($data[0])) {
			$offset = 0;

			while (($pos = strpos($str, &#039;?&#039;, $offset)) !== false) {
				$val = array_shift($data);
				$offset = $pos + strlen($val);
				$str = substr_replace($str, $val, $pos, 1);
			}
			return $options[&#039;clean&#039;] ? static::clean($str, $options) : $str;
		}

		foreach ($data as $key =&gt; $value) {
			if (!$key = sprintf($format, preg_quote($key, &#039;/&#039;))) {
				continue;
			}
			$hash = crc32($key);

			$str = preg_replace($key, $hash, $str);
			$str = str_replace($hash, $value, $str);
		}

		if (!isset($options[&#039;format&#039;]) &amp;&amp; isset($options[&#039;before&#039;])) {
			$str = str_replace($options[&#039;escape&#039;] . $options[&#039;before&#039;], $options[&#039;before&#039;], $str);
		}
		return $options[&#039;clean&#039;] ? static::clean($str, $options) : $str;
	}

	/**
	 * Cleans up a `String::insert()` formatted string with given `$options` depending
	 * on the `&#039;clean&#039;` option. The goal of this function is to replace all whitespace
	 * and unneeded mark-up around place-holders that did not get replaced by `String::insert()`.
	 *
	 * @param string $str The string to clean.
	 * @param array $options Available options are:
	 *        - `&#039;after&#039;`: characters marking the end of targeted substring.
	 *        - `&#039;andText&#039;`: (defaults to `true`).
	 *        - `&#039;before&#039;`: characters marking the start of targeted substring.
	 *        - `&#039;clean&#039;`: `true` or an array of clean options:
	 *          - `&#039;gap&#039;`: Regular expression matching gaps.
	 *          - `&#039;method&#039;`: Either `&#039;text&#039;` or `&#039;html&#039;` (defaults to `&#039;text&#039;`).
	 *          - `&#039;replacement&#039;`: String to use for cleaned substrings (defaults to `&#039;&#039;`).
	 *          - `&#039;word&#039;`: Regular expression matching words.
	 * @return string The cleaned string.
	 */
	public static function clean($str, array $options = array()) {
		if (is_array($options[&#039;clean&#039;])) {
			$clean = $options[&#039;clean&#039;];
		} else {
			$clean = array(
				&#039;method&#039; =&gt; is_bool($options[&#039;clean&#039;]) ? &#039;text&#039; : $options[&#039;clean&#039;]
			);
		}

		switch ($clean[&#039;method&#039;]) {
			case &#039;text&#039;:
				$clean += array(
					&#039;word&#039; =&gt; &#039;[\w,.]+&#039;,
					&#039;gap&#039; =&gt; &#039;[\s]*(?:(?:and|or|,)[\s]*)?&#039;,
					&#039;replacement&#039; =&gt; &#039;&#039;
				);
				$before = preg_quote($options[&#039;before&#039;], &#039;/&#039;);
				$after = preg_quote($options[&#039;after&#039;], &#039;/&#039;);

				$kleenex = sprintf(
					&#039;/(%s%s%s%s|%s%s%s%s|%s%s%s%s%s)/&#039;,
					$before, $clean[&#039;word&#039;], $after, $clean[&#039;gap&#039;],
					$clean[&#039;gap&#039;], $before, $clean[&#039;word&#039;], $after,
					$clean[&#039;gap&#039;], $before, $clean[&#039;word&#039;], $after, $clean[&#039;gap&#039;]
				);
				$str = preg_replace($kleenex, $clean[&#039;replacement&#039;], $str);
			break;
			case &#039;html&#039;:
				$clean += array(
					&#039;word&#039; =&gt; &#039;[\w,.]+&#039;,
					&#039;andText&#039; =&gt; true,
					&#039;replacement&#039; =&gt; &#039;&#039;
				);
				$kleenex = sprintf(
					&#039;/[\s]*[a-z]+=(&quot;)(%s%s%s[\s]*)+\\1/i&#039;,
					preg_quote($options[&#039;before&#039;], &#039;/&#039;),
					$clean[&#039;word&#039;],
					preg_quote($options[&#039;after&#039;], &#039;/&#039;)
				);
				$str = preg_replace($kleenex, $clean[&#039;replacement&#039;], $str);

				if ($clean[&#039;andText&#039;]) {
					return static::clean($str, array(
						&#039;clean&#039; =&gt; array(&#039;method&#039; =&gt; &#039;text&#039;)
					) + $options);
				}
			break;
		}
		return $str;
	}

	/**
	 * Extract a part of a string based on a regular expression `$regex`.
	 *
	 * @param string $regex The regular expression to use.
	 * @param string $str The string to run the extraction on.
	 * @param integer $index The number of the part to return based on the regex.
	 * @return mixed
	 */
	public static function extract($regex, $str, $index = 0) {
		if (!preg_match($regex, $str, $match)) {
			return false;
		}
		return isset($match[$index]) ? $match[$index] : null;
	}

	/**
	 * Tokenizes a string using `$options[&#039;separator&#039;]`, ignoring any instances of
	 * `$options[&#039;separator&#039;]` that appear between `$options[&#039;leftBound&#039;]` and
	 * `$options[&#039;rightBound&#039;]`.
	 *
	 * @param string $data The data to tokenize.
	 * @param array $options Options to use when tokenizing:
	 *              -`&#039;separator&#039;` _string_: The token to split the data on.
	 *              -`&#039;leftBound&#039;` _string_: Left scope-enclosing boundary.
	 *              -`&#039;rightBound&#039;` _string_: Right scope-enclosing boundary.
	 * @return array Returns an array of tokens.
	 */
	public static function tokenize($data, array $options = array()) {
		$options += array(&#039;separator&#039; =&gt; &#039;,&#039;, &#039;leftBound&#039; =&gt; &#039;(&#039;, &#039;rightBound&#039; =&gt; &#039;)&#039;);

		if (!$data || is_array($data)) {
			return $data;
		}

		$depth = 0;
		$offset = 0;
		$buffer = &#039;&#039;;
		$results = array();
		$length = strlen($data);
		$open = false;

		while ($offset &lt;= $length) {
			$tmpOffset = -1;
			$offsets = array(
				strpos($data, $options[&#039;separator&#039;], $offset),
				strpos($data, $options[&#039;leftBound&#039;], $offset),
				strpos($data, $options[&#039;rightBound&#039;], $offset)
			);

			for ($i = 0; $i &lt; 3; $i++) {
				if ($offsets[$i] !== false &amp;&amp; ($offsets[$i] &lt; $tmpOffset || $tmpOffset === -1)) {
					$tmpOffset = $offsets[$i];
				}
			}

			if ($tmpOffset === -1) {
				$results[] = $buffer . substr($data, $offset);
				$offset = $length + 1;
				continue;
			}
			$buffer .= substr($data, $offset, ($tmpOffset - $offset));

			if ($data[$tmpOffset] === $options[&#039;separator&#039;] &amp;&amp; $depth === 0) {
				$results[] = $buffer;
				$buffer = &#039;&#039;;
			} else {
				$buffer .= $data{$tmpOffset};
			}

			if ($options[&#039;leftBound&#039;] !== $options[&#039;rightBound&#039;]) {
				if ($data[$tmpOffset] === $options[&#039;leftBound&#039;]) {
					$depth++;
				}
				if ($data[$tmpOffset] === $options[&#039;rightBound&#039;]) {
					$depth--;
				}
				$offset = ++$tmpOffset;
				continue;
			}

			if ($data[$tmpOffset] === $options[&#039;leftBound&#039;]) {
				($open) ? $depth-- : $depth++;
				$open = !$open;
			}
			$offset = ++$tmpOffset;
		}

		if (!$results &amp;&amp; $buffer) {
			$results[] = $buffer;
		}
		return $results ? array_map(&#039;trim&#039;, $results) : array();
	}
}</code></pre>
					</div>
				</div>
			</section>
							</div>
	</article>			</div>
		</div>
		<footer class="main">
	<div class="area"></div>
	<div class="area"></div>
	<div class="area"></div>
	<div class="area"></div>

	<div class="social">
		<a href="https://github.com/unionofrad" target="new">GitHub</a>		<span class="separator">/</span>
		<a href="https://twitter.com/unionofrad" target="new">Twitter</a>		<span class="separator">/</span>
		<a href="http://www.reddit.com/r/li3" target="new">Reddit</a>		<span class="separator">/</span>
		<a href="https://stackoverflow.com/questions/tagged/lithium" target="new">Stack Overflow</a>	</div>
	<div class="testimonial">
		<img src="../../../../../../assets/v:__PROJECT_VERSION_BUILD__xyzz/img/testimonials/10.png" alt="Testimonial Image" />		<p>I think it's time you started<br />
writing better code.</p>
	</div>
	<div class="copyright">
		Pretty much everything is (c) 2009-2024 and beyond, the <a href="http://unionofrad.org">Union of RAD</a>.	</div>
</footer>	</body>
</body>
</html>
